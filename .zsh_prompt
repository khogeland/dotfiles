function _git_fetch_origin() {
    if [[ ! -e '.git' || ! -d '.git' ]]; then
        return 0
    else
        ({
            GIT_TERMINAL_PROMPT=0 git fetch origin main 2>/dev/null
            touch .git/.last-origin-fetch
        } &)
    fi
}

function git_commits_ahead_main() {
    if $(command git rev-parse --git-dir > /dev/null 2>&1)
    then
        local COMMITS="$(git rev-list --count origin/main..HEAD)" 2>/dev/null
        echo "$ZSH_THEME_GIT_COMMITS_AHEAD_PREFIX$COMMITS$ZSH_THEME_GIT_COMMITS_AHEAD_SUFFIX"
    fi
}

function git_commits_behind_main() {
    if $(command git rev-parse --git-dir > /dev/null 2>&1)
    then
        echo $(git rev-list --count HEAD..origin/main) 2>/dev/null
    fi
}

export GIT_COLOR_DIRTY="%{$fg[red]%}"
export GIT_COLOR_CLEAN="%{$fg[cyan]%}"

function _git_color() {
    if git diff-index --quiet HEAD -- >/dev/null 2>&1; then
        echo -n "$GIT_COLOR_CLEAN"
    else
        echo -n "$GIT_COLOR_DIRTY"
    fi
}

# git info prompt that shows commits head and behind main
function much_git_prompt_info() {
    local ref
    if [[ "$(command git config --get oh-my-zsh.hide-status 2>/dev/null)" != "1" ]]
    then
        ref=$(command git symbolic-ref HEAD 2> /dev/null)  || ref=$(command git rev-parse --short HEAD 2> /dev/null)  || return 0
        color_one="$(_git_color)"
        color_two="%{$reset_color%}%{$fg[green]%}"
        BEHIND=${$(git_commits_behind_main 2>/dev/null):-0}
        BEHIND_PROMPT=
        if [ $BEHIND -gt 0 ]; then
            BEHIND_PROMPT="${GIT_COLOR_DIRTY}$BEHIND${color_two}:"
        fi
        AHEAD=${$(git_commits_ahead_main 2>/dev/null):-0}
        AHEAD_PROMPT=
        if [ $AHEAD -gt 0 ]; then
            AHEAD_PROMPT="${color_two}:${color_one}$AHEAD"
        fi
        echo "${color_two}(${color_one}${BEHIND_PROMPT}${color_one}${ref#refs/heads/}${AHEAD_PROMPT}${color_two})%{$reset_color%}"
    fi
}
### Prompt ###
setopt PROMPT_SUBST
export status_dollar="%(?:%{$fg[magenta]%}$:%{$fg[red]%}$)%{$reset_color%}"
export ZSH_THEME_GIT_PROMPT_PREFIX="%{$fg[blue]%}(%{$fg[red]%}"
export PROMPT='%{$fg[yellow]%}%c%{$reset_color%} ${status_dollar} '

export PERIOD=15
autoload -Uz add-zsh-hook

# git-fetch every minute if possible
add-zsh-hook periodic _git_fetch_origin
PROMPT_SSH_PREFIX="[`hostname -s`] "
if [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" ]]; then
    export PROMPT="$PROMPT_SSH_PREFIX$PROMPT"
fi

if [ "$COPY_MODE" ]; then
    export PROMPT="$ "
fi

function rprompt_cmd {
    if [ ! "$COPY_MODE" ]; then
        much_git_prompt_info
    fi
}

############## <copied stuff>
# Thanks to Anish Athalye for the very useful code below!
#
#**Copyright (c) 2013-2015 Anish Athalye (me@anishathalye.com)**

#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in
#the Software without restriction, including without limitation the rights to
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
#of the Software, and to permit persons to whom the Software is furnished to do
#so, subject to the following conditions:

#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.

RPROMPT=''

ASYNC_PROC=0
function precmd() {
    function async() {
        # save to temp file
        printf "%s" "$(rprompt_cmd)" > "/tmp/zsh_prompt_$$"

        # signal parent
        kill -s USR1 $$
    }

    # do not clear RPROMPT, let it persist

    # kill child if necessary
    if [[ "${ASYNC_PROC}" != 0 ]]; then
        kill -s HUP $ASYNC_PROC >/dev/null 2>&1 || :
    fi

    # start background computation
    async &!
    ASYNC_PROC=$!
}

function TRAPUSR1() {
    # read from temp file
    RPROMPT="$(cat /tmp/zsh_prompt_$$)"

    # reset proc number
    ASYNC_PROC=0

    # redisplay
    zle && zle reset-prompt
}

############## </copied stuff>
